flatPos = transform.position;
        var trajectorySpeed = 1.0;
        flatPos.add( tmp1.copy(zVector).multiplyScalar(trajectorySpeed) );
        targetVector.copy( target).sub( startPos );
      	currentVector .copy( flatPos).sub( startPos);
				var relative = currentVector.length() / targetVector.length();
				
				var scaledT =  2.0 * (relative - 0.5);  var trajectoryScale = .1;
				var paraboleY = (1.0 - scaledT * scaledT) * trajectoryScale;

				var pos = flatPos;
				pos.y += paraboleY;

        var testAngle = -angle + angleSpeed * time;
        direction.copy(pos ).sub( lastPos);
        transform.lookAt(direction.add(transform.position));
	


var inc=.7;
	if (event.clientX < 20){
		mouse.clientX=-inc;
	}else if (event.clientX>innerWidth-20){
		mouse.clientX=inc;
	} else if (event.clientY<15){
		mouse.clientY=-inc;
	}else if (event.clientY>innerHeight-20){
		mouse.clientY=inc;
	}
  var v0 =new THREE.Vector2( 155,  321),
		v1 =new THREE.Vector2(310,  321),

		v2=new THREE.Vector2(113 , 633),
		v3=new THREE.Vector2(401,633);
    
    clientX=event.offsetX *(worldSize.x/size);
			clientY=event.offsetY*(worldSize.y/size);
			clientX += v0.x;
			clientY += v0.y;
			clientX = clientX-camera.position.x ;
			clientY= clientY-camera.position.z ;
